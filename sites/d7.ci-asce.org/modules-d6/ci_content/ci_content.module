<?php
/**
 * Implementation of hook_node_info
 */
function ci_content_node_info() {
  $desc = 'A test content type primarily created for the CI site. ' . 
  	'This content type has fields that have been defined for use in ' . 
  	'laying out content on the CI website.';
	$desc = t($desc);	
  return array(
    'ci_content' => array(
      'name' => t('CI Content'),
      'module' => 'ci_content',
      'description' => $desc,
    ),
  );
}

/**
 * Implementation of hook_init()
 */
function ci_content_init() {
	drupal_add_css(drupal_get_path('module', 'ci_content') . '/css/ci-content.css');
}

/**
 * Implementation of hook_views_api().
 */
function ci_content_views_api() {
  return array(
    'api' => 2,
    //'path' => drupal_get_path('module', 'ci_content') . '/views',
  );
}

/**
 * Implementation of hook_perm
 */
function ci_content_perm() {
  return array('create ci content', 'edit own ci content', 'edit any ci content', 'delete own ci content', 'delete any ci content');
}

/**
 * Implementation of hook_theme()
 */
function ci_content_theme() {
  return array(
    'ci_content' => array(
    	'pattern' => 'ci_content__',
      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),
      'template' => 'ci-content',
    ),
  );
}

/**
 * Implementation of hook_access().
 */
function ci_content_access($op, $node, $account) {
  switch ($op) {
    case 'create':
      if (user_access('create ci content', $account)) {
        return TRUE;
      }
      break;

    case 'update':
      if (user_access('edit any ci content', $account) || ($account->uid == $node->uid && user_access('edit own ci content', $account))) {
        return TRUE;
      }
      break;

    case 'delete':
      if (user_access('delete any ci content', $account) || ($account->uid == $node->uid && user_access('delete own ci content', $account))) {
        return TRUE;
      }
      break;
  }
}

/**
 * Implementation of hook_form().
 * 
 * This really doesn't do anything; we just have it here because if this function is not present
 * then it will not show up in the node/add page, we also need it to make sure that
 * Title and Body Fields appear.
 */
function ci_content_form(&$node, $form_state) {
	global $user;
	$form_state = array();
	$form = node_content_form($node, $form_state);
	return $form;
}

/**
 * Generate a teaser display of a given node.
 *
 * @param $node
 *   A node array or node object.
 * @param $teaser
 *   Whether to display the teaser only or the full form.
 * @param $page
 *   Whether the node is being displayed by itself as a page.
 * @param $links
 *   Whether or not to display node links. Links are omitted for node previews.
 *
 * @return
 *   An HTML representation of the themed node.
 */
function ci_content_teaser_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {	
  $node = (object)$node;

  $node = node_build_content($node, $teaser, $page);

  if ($links) {
    $node->links = module_invoke_all('link', 'node', $node, $teaser);
    drupal_alter('link', $node->links, $node);
  }

  // Set the proper node part, then unset unused $node part so that a bad
  // theme can not open a security hole.
  $content = drupal_render($node->content);
  if ($teaser) {
    $node->teaser = $content;
    unset($node->body);
  }
  else {
    $node->body = $content;
    unset($node->teaser);
  }

  // Allow modules to modify the fully-built node.
  node_invoke_nodeapi($node, 'alter', $teaser, $page);

  return theme(array('ci_content_teaser', 'ci_content'), $node, $teaser, $page);
}

/**
 * Implementation of hook_form_alter()
 */
function ci_content_form_alter(&$form, &$form_state, $form_id) {
	//dpm($form_id);
	// Do not show the group page that is defined using CCK
	if ($form_id == 'ci_content_node_form') {
		if(user_access('administer nodes')) {
			$node = $form['#node'];
			$mess = 'node_type: ' . $node->type;
			drupal_set_message($mess);
		}
		if (isset($form['group_page'])) {
			$form['group_page']['#access'] = TRUE;
		}
		if (isset($form['field_front_layout'])) {
			$form['field_front_layout']['#access'] = TRUE;
		}
	}
}

function ci_content_form_ci_content_node_form_alter(&$form, &$form_state) {
}
 
/**
 * Implementation of modulename_preprocess_hook
 */
function ci_content_preprocess_page (&$variables) {
  $title = menu_get_active_title();
  //$variables['title'] = $title;
}

/**
 * Template helper for theme_views_view_row_node
 */
function template_preprocess_ci_content(&$variables) {  
	// Since we are just modifying the node template a bit, we just tap into the
	// node preprocessor functions by copying them from the theme registry
		drupal_add_css(drupal_get_path('module', 'ci_content') . '/css/ci-content.css');
	init_theme();
	$registry = theme_get_registry();
	$node_theme = $registry['node']['preprocess functions'];
	array_shift($node_theme);
	$args = array(&$variables, $hook);
	if(isset($node_theme)) {
		foreach($node_theme as $preprocess_function) {
			call_user_func_array($preprocess_function, $args);
		}
	}
}

/**
 * A theme preprocess function to automatically allow view-based node
 * templates if called from a view.
 *
 * The 'modules/node.views.inc' file is a better place for this, but
 * we haven't got a chance to load that file before Drupal builds the
 * node portion of the theme registry.
 */
function ci_content_preprocess_ci_content(&$vars) {
  // The 'view' attribute of the node is added in template_preprocess_views_view_row_node()
  if (!empty($vars['node']->view) && !empty($vars['node']->view->name)) {
    $vars['view'] = &$vars['node']->view;
    $vars['template_files'][] = 'node-view-' . $vars['node']->view->name;
    if(!empty($vars['node']->view->current_display)) {
      $vars['template_files'][] = 'node-view-' . $vars['node']->view->name . '-' . $vars['node']->view->current_display;
    }
  }
}

/**
 * Generate a teaser for a node body.
 *
 * If the end of the teaser is not indicated using the <!--break--> delimiter
 * then we generate the teaser automatically, trying to end it at a sensible
 * place such as the end of a paragraph, a line break, or the end of a
 * sentence (in that order of preference).
 *
 * @param $body
 *   The content for which a teaser will be generated.
 * @param $format
 *   The format of the content. If the content contains PHP code, we do not
 *   split it up to prevent parse errors. If the line break filter is present
 *   then we treat newlines embedded in $body as line breaks.
 * @param $size
 *   The desired character length of the teaser. If omitted, the default
 *   value will be used. Ignored if the special delimiter is present
 *   in $body.
 * @return
 *   The generated teaser.
 */
function ci_content_teaser($body, $nid, $format = NULL, $size = NULL) {

  if (!isset($size)) {
    $size = variable_get('teaser_length', 800);
  }

  // We check for the presence of the PHP evaluator filter in the current
  // format. If the body contains PHP code, we do not split it up to prevent
  // parse errors.
  if (isset($format)) {
    $filters = filter_list_format($format);
    if (isset($filters['php/0']) && strpos($body, '<?') !== FALSE) {
      return $body;
    }
  }

  // If we have a short body, the entire body is the teaser.
  if (drupal_strlen($body) <= $size) {
    return $body;
  }

  // If the delimiter has not been specified, try to split at paragraph or
  // sentence boundaries.

  // The teaser may not be longer than maximum length specified. Initial slice.
  $teaser = truncate_utf8($body, $size);

  // Store the actual length of the UTF8 string -- which might not be the same
  // as $size.
  $max_rpos = strlen($teaser);

  // How much to cut off the end of the teaser so that it doesn't end in the
  // middle of a paragraph, sentence, or word.
  // Initialize it to maximum in order to find the minimum.
  $min_rpos = $max_rpos;

  // Store the reverse of the teaser.  We use strpos on the reversed needle and
  // haystack for speed and convenience.
  $reversed = strrev($teaser);

  // Build an array of arrays of break points grouped by preference.
  $break_points = array();

  // A paragraph near the end of sliced teaser is most preferable.
  //$break_points[] = array('</p>' => 0);

  // If no complete paragraph then treat line breaks as paragraphs.
  //$line_breaks = array('<br />' => 6, '<br>' => 4);
  // Newline only indicates a line break if line break converter
  // filter is present.
  //if (isset($filters['filter/1'])) {
  //  $line_breaks["\n"] = 1;
  //}
  //$break_points[] = $line_breaks;
	//print $teaser;
  // If the first paragraph is too long, split at the end of a sentence.
  $break_points[] = array(' ' => 1, '. ' => 1, '! ' => 1, '? ' => 1, '。' => 0, '؟ ' => 1);
  // Iterate over the groups of break points until a break point is found.
  foreach ($break_points as $points) {
    // Look for each break point, starting at the end of the teaser.
    foreach ($points as $point => $offset) {
      // The teaser is already reversed, but the break point isn't.
      $rpos = strpos($reversed, strrev($point));
      if ($rpos !== FALSE) {
        $min_rpos = min($rpos + $offset, $min_rpos);
      }
    }
   
    // If a break point was found in this group, slice and return the teaser.
    if ($min_rpos !== $max_rpos) {
      // Don't slice with length 0.  Length must be <0 to slice from RHS.
      return ($min_rpos === 0) ? $teaser : substr($teaser, 0, 0 - $min_rpos) . '...' . l(' Read more', 'node/' . $nid);
    }
  }

  // If a break point was not found, still return a teaser.
  return $teaser;
}