<?php
// $Id$

module_load_include('inc', 'cms', 'cms.actions');
module_load_include('inc', 'cms', 'cms.db_functions');
module_load_include('inc', 'cms', 'cms.conferences.inc');
/*
 * Implementation of hook_menu().
 *
 * The array of items are as follows:
 *
 * "title": Required. The untranslated title of the menu item.
 * "title callback": Function to generate the title, defaults to t(). If you require only the raw string to be output, set this to FALSE.
 * "title arguments": Arguments to send to t() or your custom callback.
 * "description": The untranslated description of the menu item.
 * "page callback": The function to call to display a web page when the user visits the path. If omitted, the parent menu item's callback will be used instead.
 * "page arguments": An array of arguments to pass to the page callback function. Integer values pass the corresponding URL component (see arg()).
 * "access callback": A function returning a boolean value that determines whether the user has access rights to this menu item. Defaults to user_access() unless a value is inherited from a parent menu item..
 * "access arguments": An array of arguments to pass to the access callback function. Integer values pass the corresponding URL component.
 * "file": A file that will be included before the callbacks are accessed; this allows callback functions to be in separate files. The file should be relative to the implementing module's directory unless otherwise specified by the "file path" option.
 * "file path": The path to the folder containing the file specified in "file". This defaults to the path to the module implementing the hook.
 * "weight": An integer that determines relative position of items in the menu; higher-weighted items sink. Defaults to 0. When in doubt, leave this alone; the default alphabetical order is usually best.
 * "menu_name": Optional. Set this to a custom menu if you don't want your item to be placed in Navigation.
 * "type": A bitmask of flags describing properties of the menu item. Many shortcut bitmasks are provided as constants in menu.inc:
 *          MENU_NORMAL_ITEM: Normal menu items show up in the menu tree and can be moved/hidden by the administrator.
 *          MENU_CALLBACK: Callbacks simply register a path so that the correct function is fired when the URL is accessed.
 *          MENU_SUGGESTED_ITEM: Modules may "suggest" menu items that the administrator may enable.
 *          MENU_LOCAL_TASK: Local tasks are rendered as tabs by default.
 *          MENU_DEFAULT_LOCAL_TASK: Every set of local tasks should provide one "default" task, that links to the same path as its parent when clicked.
 * If the "type" key is omitted, MENU_NORMAL_ITEM is assumed.
 */
function cms_menu() {
	global $user;
	
	$items = array();
  $base = array (
    'access callback' => TRUE,
    'file' => 'cms.pages.inc',
  );
	$items['conferences'] = array(
    'title' => t('Conferences'),
    'description' => t('Conferences'),
    'page callback' => 'asce_conferences_home',
	) + $base;
	
	$conferences = cms_get_conferences();
	foreach($conferences as $key => $conference) {
	  $items['conferences/' . $conference->url] = array(
	    'title' => t($conference->event),
	    'page callback' => 'cms_conf_page_view',
  	  'page arguments' => array(1, 'welcome'),
    	'access callback' => 'cms_conf_page_access',
    	'access arguments' => array(1, 'welcome'),
	  ) + $base;
		$tabs = cms_get_tabs($conference->event_id);
		if($tabs) {
			$first = TRUE;
			foreach($tabs as $tab) {		
			  $items['conferences/' . $conference->url . '/' . $tab->name] = array(
			    'title' => t($tab->title),
			    'description' => t($tab->title),
			    'page callback' => 'cms_conf_page_view',
		  	  'page arguments' => array(1, 2),
		    	'access callback' => 'cms_conf_page_access',
		    	'access arguments' => array(1, "$tab->name"),
		    	'type' => $first ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
		    	'weight' => $tab->weight,
			  );
				// if($tab->name == 'program') {
					// $items['conferences/' . $conference->url . '/' . $tab->name]['page callback'] = 'cms_program_page';
					// $items['conferences/' . $conference->url . '/' . $tab->name]['page arguments'] = array($conference->event_id);
					// $items['conferences/' . $conference->url . '/' . $tab->name]['file'] = 'cms.pages.inc';
				// }
        if($tab->name == 'abstracts1') {
          $items['conferences/' . $conference->url . '/' . $tab->name]['page callback'] = 'cms_abstracts_page';
          $items['conferences/' . $conference->url . '/' . $tab->name]['page arguments'] = array($conference->event_id);
          $items['conferences/' . $conference->url . '/' . $tab->name]['file'] = 'cms.pages.inc';
          unset($items['conferences/' . $conference->url . '/' . $tab->name]['access arguments']);
          $items['conferences/' . $conference->url . '/' . $tab->name]['access arguments'] = array('administer cms');
        }
				$first = FALSE;
			}
		}
	}
  $items['conferences/%/abstract/submit'] = array(
    'title' => t('Submit Abstract'),
    'description' => t('Submit an abstract for a conference'),
    'page callback' => 'cms_abstract',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  ) + $base;  
  $items['conferences/%/abstract/%/topic'] = array(
    'title' => t('Abstract Topic'),
    'description' => t('Assign a topic to abstract'),
    'page callback' => 'cms_assign_topic',
    'page arguments' => array(1, 3),
    'type' => MENU_CALLBACK,
  ) + $base;  
  $items['conferences/%/abstract/%/add-new-topic'] = array(
    'title' => t('Add New Topic'),
    'description' => t('Add a new topic'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cms_add_topic_form', 1, 3),
    'type' => MENU_CALLBACK,
  ) + $base;  
  $items['conferences/%/abstract/%/author'] = array(
    'title' => t('Abstract Topic'),
    'description' => t('Add author to abstract'),
    'page callback' => 'cms_add_author',
    'page arguments' => array(1, 3),
    'type' => MENU_CALLBACK,
  ) + $base;
	  
	// Admin menu items
	$base = array(
    'access arguments' => array('administer cms'),
    'file' => 'cms.admin.inc',
  );
  $items['admin/content/cms'] = array(
    'title' => t('Conferences'),
    'description' => t('List conferences'),
    'page callback' => 'cms_conf_list',
  ) + $base;
  $items['admin/content/cms/list'] = array(
    'title' => t('List'),
    'description' => t('List conferences'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  ) + $base;  	
  $items['admin/content/cms/add'] = array(
    'title' => 'Add new conference',
    'description' => 'Add new conference',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cms_conf_add_form'),
    'type' => MENU_LOCAL_TASK,
    'weight' =>-9,
  ) + $base;

	$base = array(
		'access callback' => 'cms_menu_access',
    'file' => 'cms.admin.inc',
  );	    
	// Conference specific admin menu items
	// these are the tabs, depending on users, not all tabs are seen
	$conferences = cms_get_conferences();
	foreach($conferences as $key => $conference) {
		$url = $conference->url;
	  $items['admin/content/cms/' . $url ] = array(
	    'title' => t($conference->event),
	    'description' => 'Overview',
	    'page callback' => 'drupal_get_form',
	    'page arguments' => array('cms_conf_edit_form', 3),
	    'access callback' => 'user_access',
	    'access arguments' => array('administer cms'),
	  ) + $base;
	  $items['admin/content/cms/' . $url . '/edit'] = array(
	    'title' => t('Overview'),
	    'description' => 'Overview',
	    'type' => MENU_DEFAULT_LOCAL_TASK,
	    'weight' => -10,
	  ) + $base;  			
		$items['admin/content/cms/' . $url . '/abstracts'] = array(
	    'title' => t('Abstracts'),
	    'description' => 'Manage abstracts for a specific conference.',
	    'page callback' => 'cms_manage_abstracts',
	    'access arguments' => array('abstracts'),
	    'page arguments' => array(3),
	    'type' => MENU_LOCAL_TASK,
	    'weight' => 0,
	  ) + $base;
		$items['admin/content/cms/' . $url . '/topics'] = array(
	    'title' => t('Topics'),
	    'description' => 'Manage topics and subtopics for a specific conference.',
	    'page callback' => 'cms_manage_topics',
	    'access arguments' => array('topics'),
	    'page arguments' => array(3),
	    'type' => MENU_LOCAL_TASK,
	    'weight' => 0,
	  ) + $base;
		$items['admin/content/cms/' . $url . '/users'] = array(
	    'title' => t('Users'),
	    'description' => 'Manage users for a specific conference',
	    'page callback' => 'cms_manage_users',
	    'access arguments' => array('users'),
	    'page arguments' => array(3),
	    'type' => MENU_LOCAL_TASK,
	    'weight' => 1,
	  ) + $base;
		$items['admin/content/cms/' . $url . '/email'] = array(
	    'title' => t('E-mail'),
	    'description' => 'E-mail administration for a specific conference',
	    'page callback' => 'cms_manage_email',
	    'access arguments' => array('email'),
	    'page arguments' => array(3),
	    'type' => MENU_LOCAL_TASK,
	    'weight' => 2,
	  ) + $base;
		$items['admin/content/cms/' . $url . '/abstracts/%/%'] = array(
	    'title' => t('Abstracts'),
	    'description' => 'Abstract List',
	    'page callback' => 'cms_abstract_list',
	    'page arguments' => array(5, 6),
	    'access arguments' => array('abstracts'),
	  ) + $base;		
	}
	
	// Other items
  $items['cms/autocomplete'] = array(
    'title' => '',
    'page callback' => 'cms_autocomplete_multiple',
    'access callback' => 'cms_menu_access',
    'access arguments' => array('administer cms'),
    'type' => MENU_CALLBACK,
  );
	
	// TODO: Fix these topic management menu items
  $items['admin/content/cms/abstracts/%/topic/%'] = array(
    'title' => 'Abstract Management',
    'description' => 'Manage abstracts submitted.',
    'page callback' => 'cms_abstract_list',
    'page arguments' => array(4, 6),
  ) + $base;  
  $items['admin/content/cms/abstracts/%/subtopic/%'] = array(
    'title' => 'Abstract Management',
    'description' => 'Manage abstracts submitted.',
    'page callback' => 'cms_abstract_list',
    'page arguments' => array(4,6),
  ) + $base;
	$items['admin/content/cms/topics/%'] = array(
    'title' => 'Manage Topics',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cms_topics_form', 4),
    'access arguments' => array('administer menu'),
    'type' => MENU_CALLBACK,
    'file' => 'cms.admin.inc',
  );
  $items['admin/content/cms/topics/%/list'] = array(
    'title' => 'List topics',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'cms.admin.inc',
  );
  $items['admin/content/cms/topics/%/add'] = array(
    'title' => 'Add topic',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cms_edit_topic', 'add', NULL, 4),
    'access arguments' => array('administer menu'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'cms.admin.inc',
  );

	// Debug menu items
	$items['admin/content/cms/topics/%/debug'] = array(
    'title' => t('Debug'),
    'page callback' => 'cms_debug',
    'access arguments' => array('administer menu'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'cms.admin.inc',
  );
  return $items;
}

function cms_menu_alter(&$items) {
	unset($items['conferences/2013_corpus']);
	$items['conferences/2013_corpus'] = array (
		'title' => t('CALL FOR PAPERS AND POSTERS'),
    'description' => 'Corpus Christi 2013 Call',
    'page callback' => 'cms_conf_corpus',
    'access callback' => TRUE,
    'file' => 'cms.admin.inc',
    'file path' => drupal_get_path('module', 'cms'),
	);
}

/**
 * Implementation of hook_views_api().
 */
function cms_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'cms') . '/views',
  );
}

function cms_init() {
	$js  = '<script type="text/javascript" src="http://platform.linkedin.com/in.js">\n';
	$js .= '  api_key: df2v80gxu2ba.\n';
	$js .= '</script>';
	//drupal_add_js($js, 'inline', 'header', 'src=http://platform.linkedin.com/in.js"\n');
}
/**
* Implementation of hook_perm().
*/
function cms_perm() {
  return array('administer cms', 'view abstract reports');
}

/**
 * Implementation of hook_action_info()
 */
function cms_action_info() {
	$info['assign_topic_action'] = array(
    'type' => 'node',
    'description' => t('Select a topic for abstract'),
    'configurable' => FALSE,
    'hooks' => array(
      'nodeapi' => array('insert', 'update', 'delete'),
    ),
  );
  return $info;  
}

function cms_load($node) {
	//dpm($node);
}
/**
 * Implementation of hook_nodeapi().
 */
function cms_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
	// Only do this for abstract content types
	if (is_abstract($node)) {
		global $user;
	  
	  switch ($op) {
			case 'view':
				if ($_GET['program'] && $_GET['destination']) {
					$bc = drupal_get_breadcrumb();
					$bc[] = l('Program', $_GET['destination']);
					drupal_set_breadcrumb($bc);
				}
				break;
			case 'load':
	      // Store current status for later reference
	      $node->old_status = $node->status;
	      break;
	    case 'update':
	    case 'insert':
				global $base_url;
				$account = user_load($user->uid);
				switch($base_url) {
					case 'http://lc.ci-asce.org':
						$send_method = 'privatemsg';
						$destinations[] = $account;
						break;
					case 'http://ci-asce.org':
						$send_method = 'plain-mail';
						$destinations[] = $account->mail;
						break;
				}
				$object = node_load($node->nid);
				$message = cms_process_message($account, $op, $send_method, $object);
				if (messaging_message_send($destinations, $message, $send_method)) {
					$mess = "An email was sent to $account->mail. You should receive it in the next few minutes. If not, please be sure to check your spam.";
					$mess .= "Be sure to add ci@ci-asce.org to your spam filter; otherwise, you may not receive important emails regarding your ";
					$mess .= "abstract submission. For any inquiries contact klachinova@asce.org";
					$mess = t($mess);
					drupal_set_message($mess);
				}
				else {
					drupal_set_message('Failed!!');
				}
	      break;
			case 'delete':
				db_query("DELETE FROM {cms_abstract} WHERE abstract_nid = %d", $node->nid);
				db_query("DELETE FROM {cms_abstract_authors} WHERE abstract_nid = %d", $node->nid);
	      // Remove all subscriptions for this abstract
	      notifications_delete_subscriptions(array('event_type' => 'node'), array('nid' => $node->nid), FALSE);
	      break;
		}
	}
	else {
		switch($op) {
			case 'load':
				// We want to check and see if this node is the main page for a conference
				$sql = "SELECT * FROM cms_nodes WHERE type = 'welcome'";
				$results = db_query($sql);
				while($row = db_fetch_object($results)) {
					$nids[] = $row->nid;
					$nids[$row->nid]['nid'] = $row->nid;
					$nids[$row->nid]['eid'] = $row->eid;
				}
				if(in_array($node->nid, $nids)) {
					$conference = cms_get_conference($nids[$node->nid]['eid'], TRUE);
					$node->cms = $conference;
				}
				break;
		}
	} 
}

/**
 * Helper function
 */
function _cms_get_abstract_info($nid) {
	
}

/**
 * Determine if a given node is an abstract.
 * @param $type
 *   The node object or the node's type
 */
function is_abstract($type) {
  if (is_object($type)) {
    $type = $type->type;
  }
	if($type == 'abstract') {
		return TRUE;
	}
}

/**
 * Implementation of hook_theme().
 */
function cms_theme() {
  return array(
    'abstract_authors' => array(
      'arguments' => array('abstract_nid'),
    ),
    'submissions' => array(
      'arguments' => array('submissions'), 
    ),
    'cms_manage_users_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'cms.admin.inc',
    ),
    'cms_node' => array(
      'arguments' => array('node' => NULL, 'teaser' => FALSE, 'page' => FALSE),
      'template' => 'cms-node',
    ),
    'cms_program_group_heading' => array(
			'arguments' => array('heading' => NULL, 'teaser' => TRUE),
			'template' => 'cms-program-group-heading',
		),
    'cms_program_abstract' => array(
			'arguments' => array('abstract' => NULL, 'teaser' => TRUE),
			'template' => 'cms-program-abstract',
		),
		'cms_program_intro' => array(
			'arguments' => array(),
			'template' => 'cms-program-intro',
		),
  );
}

/**
 * Implementation of hook_ci_links()
 * 
 * @see
 * 	ci module
 */
function cms_ci_links($account = NULL) {
	if(!$account) {
		global $user;
		$account = user_load($user->uid);
	}
	// Provide administrator links
	$sql = "SELECT * FROM cms_uid WHERE uid = %d";
	$results = db_query($sql, $account->uid);
	while($row = db_fetch_object($results)) {
		$conference = cms_get_conference($row->eid, TRUE);
		$eids[$row->eid] = $conference;
	}
	if ($eids) {
		foreach($eids as $conference) {
			$links[] = l('View ' . $conference->event . ' abstracts', 'admin/content/cms/' . $conference->url . '/abstracts');
		}
	}
	$links[] = l('Submit a presentation abstract to the ASCE Texas Section/CI Summit in Fort Worth', 'conferences/2012_summit', array('query' => drupal_get_destination()));
	return $links;	
}

function cms_access_abstracts() {
		
		global $user;
		$account = user_load($user->uid);
}

/**
 * Implementation of hook_block().
 */
function cms_block($op = 'list', $delta = 0, $edit = array()) {
	if ($op == 'list') {
		// returns array, with the following key-value pairs:
		//
		// 'info': (required) The human-readable name of the block. This is used to identify the block on administration screens, and is not displayed to non-administrative users.
		// 'cache': A bitmask of flags describing how the block should behave with respect to block caching. The following shortcut bitmasks are provided as constants in block.module:
		//    BLOCK_CACHE_PER_ROLE (default): The block can change depending on the roles the user viewing the page belongs to.
		//    BLOCK_CACHE_PER_USER: The block can change depending on the user viewing the page. This setting can be resource-consuming for sites with large number of users, and should only be used when BLOCK_CACHE_PER_ROLE is not sufficient.
		//    BLOCK_CACHE_PER_PAGE: The block can change depending on the page being viewed.
		//    BLOCK_CACHE_GLOBAL: The block is the same for every user on every page where it is visible.
		//    BLOCK_NO_CACHE: The block should not get cached.
		// 'weight': (optional) Initial value for the ordering weight of this block. Most modules do not provide an initial value, and any value provided can be modified by a user on the block configuration screen.
		// 'status': (optional) Initial value for block enabled status. (1 = enabled, 0 = disabled). Most modules do not provide an initial value, and any value provided can be modified by a user on the block configuration screen.
		// 'region': (optional) Initial value for theme region within which this block is set. Most modules do not provide an initial value, and any value provided can be modified by a user on the block configuration screen. Note: If you set a region that isn't available in the currently enabled theme, the block will be disabled.
		// 'visibility': (optional) Initial value for the visibility flag, which tells how to interpret the 'pages' value. Possible values are:
		//    0: Show on all pages except listed pages. 'pages' lists the paths where the block should not be shown.
		//    1: Show only on listed pages. 'pages' lists the paths where the block should be shown.
		//    2: Use custom PHP code to determine visibility. 'pages' gives the PHP code to use.
		//  Most modules do not provide an initial value for 'visibility' or 'pages', and any value provided can be modified by a user on the block configuration screen.
		// 'pages': (optional) See 'visibility' above.

		$blocks[0]['info'] = t('Temporary Block - Does Nothing');
		$blocks[0]['cache'] = BLOCK_NO_CACHE;

		return $blocks;
	}

	if ($op == 'view') {
		switch ($delta) {
			case 0:
				break;
			case 1:
				break;
		}
		return $block;
	}

	if ($op == 'configure') {
	}

	if ($op == 'save') {
	}
}

function cms_form_user_login_block_alter(&$form, $form_state) {
	$krumo = drupal_get_path('module', 'devel');
	if (arg(0) == 'conferences') {
		module_load_include('php', $krumo . '/krumo/class.krumo');
		//krumo($path);
		$options = array(
    'title' => 'Create a new user account.',
    'query' => array(
      'destination' => 'conferences',
		),
		);
		$str .= '<div class="item-list">';
		$str .=   '<ul>';
		$str .=       '<li class="first">';
		$str .= l('Create new account', 'user/register', $options);
		$str .=       '</li>';
		$str .=       '<li class="last">';
		$options = array(
    'title' => 'Request new password via e-mail.',
    'query' => array(
      'destination' => 'conferences',
		),
		);
		$str .= l('Request new password', 'user/password', $options);
		$str .= '            </li>';
		$str .= '          </ul>';
		$str .= '        </div>';
		$form['links'] = array(
    '#value' => $str, 
		);
		//krumo($form);
	}
}

/*
 * Implementation of hook_form_alter()
 */
function cms_form_alter(&$form, $form_state, $form_id) {
	//dpm($form);	
	if ($form_id == 'cms_edit_topic') {
		//dpm($form);
	}
	if (isset($form['type']) && isset($form['#node'])) {
		// Do the following only for abstract node types
		// Note: the following handles to conditions 1) a new abstract; 2) updating an abstract
		// Note: for updating an abstract, we add two buttons that will allow users to add authors
		//        and change the topic. These buttons also need to appear when viewing an abstract
		//        so also make sure any changes made here are made in abstract_view() as well.
    if ($form['type']['#value'] .'_node_form' == $form_id && $form['#node']->type == 'abstract') {
	    unset($form['body_field']['teaser_js']);
	    unset($form['body_field']['teaser_include']);
    	drupal_set_title('Submit an Abstract');
	    
	    // Modify the breadcrumb when submitting new abstract
	    if(arg(1) == 'add') {
		    $bc = drupal_get_breadcrumb();
		    $id = (int) $node->event;
		    $conference = cms_get_conference($_GET['event_id'], TRUE);
		    $bc[1] = l($conference->event, 'conferences/' . $conference->url);
		    drupal_set_breadcrumb($bc);

        // Conference selection (the user won't actually see this)
        $form['event'] = array(
          '#type' => 'value',
          '#value' => !empty($node->event) ? $node->event : $_GET['event_id'],
        );
	    }
	    
      if (arg(2) == 'edit') {
      	// Modify the breadcrumb when editing abstract
	      $bc = drupal_get_breadcrumb();
	      if (isset($form_state['values']['node'])) {
	      	dsm($form_state);
	      	$node = $form_state['values']['node'];
	      }
	      else {
	      	//drupal_set_message('form_state not set');
	       	$node = node_load(arg(1));	
	      }
	      
	      $conference = cms_get_conference($node->event, TRUE);
	      //dsm($conference);
	      $bc[1] = l($conference->event, 'conferences/' . $conference->url);
	      $bc[2] = l($node->title, 'node/' . $node->nid);
	      drupal_set_breadcrumb($bc);
	      
	      // Need to store the values for submission
	      $form['node'] = array(
	       '#type' => 'value',
	       '#value' => $node,
	      );
      }
		  return $form;
    }
  }
}

function cms_abstract_edit_buttons(&$form_state, $node) {
	module_load_include('inc', 'cms', 'cms.pages');
	if ($node->topic == 0) {
		drupal_set_message('Thank you for submitting an abstract, please give your abstract a topic by clicking on the button below.', 'status');
	  $topic_button_text = 'Provide a topic';
	}
	else {
		$topic_button_text = 'Change topic';
	}	
	$form['topic'] = array(
		'#type' => 'submit',
		'#value' => t($topic_button_text),
		'#weight' => -6,
	);
	$form['authors'] = array(
		'#type' => 'submit',
		'#value' => t('Add author/s'),
		'#weight' => -5,
	);
	
	// Store the node for passing on
	$form['node'] = array(
	  '#type' => 'value',
	  '#value' => $node,
	);
	return $form;
}

function cms_abstract_edit_buttons_submit($form, &$form_state) {
	$node = $form_state['values']['node'];
	$conference = cms_get_conference($node->event, TRUE);
	$op = $form_state['values']['op'];
	
	if ( $op == 'Change topic' || $op == 'Provide a topic') {
    $url = 'conferences/' . $conference->url . '/abstract/' . $node->nid . '/topic';		
	}
	elseif ($op == 'Add author/s') {
		$url = 'conferences/' . $conference->url . '/abstract/' . $node->nid . '/author';
	}
	drupal_goto($url);
}

function theme_abstract_authors($abstract_nid) { 
	$authors = cms_get_authors($abstract_nid);
	$o = '<p><b>Authors: </b>';
	$count = count($authors);
	foreach($authors as $key => $author) {
		$o .= $author->first . ' ' . $author->last;
		if ($author->credentials) {
			$o .= ', ' . $author->credentials; 
		} 
		if ($i < $count - 1) {
			$o .= '; ';
		}
		$i = $i + 1;
	}
	$o .= '</p>';
	return $o;
}

function theme_submissions($submissions) {
	$count = count($submissions);
	if ($count > 0) {
		if ($count > 1) {
			$o = '<h2>Your submissions:</h2>';
		}
		else {
			$o = '<h2>Your submission:</h2>';
		}
		$o .= '<ul>';
		foreach($submissions as $abstract_nid => $submission) {
			$o .= '<li>' . l($submission->title, 'node/' . $abstract_nid) . '</li>';
		}
		$o .= '</ul>';
	}
	return $o;
}

function _include_krumo() {
	module_load_include('php', 'devel', drupal_get_path('devel') . '/krumo/class.krumo');
}

/**
 * Save a topic.
 *
 * @param $item
 *   An array representing a menu link item. The only mandatory keys are
 *   link_path and link_title. Possible keys are:
 *   - eid: Unique conference id number.
 *   - weight: Default is 0.
 *   - tlid: Set to an existing value, or 0 or NULL to insert a new topic.
 *   - plid: The tlid of the parent.
 *
 * @return
 *   The tlid of the saved topic, or FALSE if the topic could not be 
 *   saved.
 */
function cms_topic_save(&$topic) {
	//dpm($topic);
  $existing_topic = FALSE;
  if (isset($topic['tlid'])) {
    $existing_topic = db_fetch_array(db_query("SELECT * FROM {cms_topics} WHERE tlid = %d", $item['tlid']));
  }

  if (isset($topic['plid'])) {
    $parent = db_fetch_array(db_query("SELECT * FROM {cms_topics} WHERE tlid = %d", $item['plid']));
  }

  if (!$existing_topic) {
  	drupal_write_record('cms_topics', $topic);
  }
	
  if (!$topic['plid']) {
    $topic['p1'] = $topic['tlid'];
    for ($i = 2; $i <= MENU_MAX_DEPTH; $i++) {
      $topic["p$i"] = 0;
    }
    $topic['depth'] = 1;
  }
  else {
    // Cannot add beyond the maximum depth.
    if ($topic['has_children'] && $existing_item) {
      $limit = MENU_MAX_DEPTH - cms_topic_children_relative_depth($existing_item) - 1;
    }
    else {
      $limit = MENU_MAX_DEPTH - 1;
    }
    if ($parent['depth'] > $limit) {
      return FALSE;
    }
    $topic['depth'] = $parent['depth'] + 1;
    _cms_topic_parents_set($topic, $parent);
  }
	drupal_write_record('cms_topics', $topic, array('tlid'));
  //Check the has_children status of the parent.
  _cms_topic_update_parental_status($topic);
  return $topic['tlid'];
}

/**
 * Return a list of menu items that are valid possible parents for the given menu item.
 *
 * @param $eid
 *   The unqieu id of the conference/event.
 * @param $item
 *   The menu item for which to generate a list of parents.
 *   If $item['mlid'] == 0 then the complete tree is returned.
 * @return
 *   An array of menu link titles keyed on the a string containing the menu name
 *   and mlid. The list excludes the given item and its children.
 */
function cms_topic_parent_options($eid, $topic) {
  // If the item has children, there is an added limit to the depth of valid parents.
  if (isset($topic['parent_depth_limit'])) {
    $limit = $topic['parent_depth_limit'];
  }
  else {
    $limit = _cms_topic_parent_depth_limit($topic);
  }
  $tree = cms_topic_tree_all_data($eid, NULL);
  _cms_topic_parents_recurse($tree, $eid, '--', $options, $topic['tlid'], $limit);
  return $options;
}

/**
 * Find the depth limit for items in the parent select.
 */
function _cms_topic_parent_depth_limit($topic) {
  return MENU_MAX_DEPTH - 1 - (($topic['tlid'] && $topic['has_children']) ? cms_topic_children_relative_depth($topic) : 0);
}

/**
 * Recursive helper function for menu_parent_options().
 */
function _cms_topic_parents_recurse($tree, $eid, $indent, &$options, $exclude, $depth_limit) {
	if ($tree) {
	  foreach ($tree as $data) {
	    if ($data['topic']['depth'] > $depth_limit) {
	      // Don't iterate through any links on this level.
	      break;
	    }
	    if ($data['topic']['tlid'] != $exclude) {
	      $title = $indent .' '. truncate_utf8($data['topic']['topic_name'], 30, TRUE, FALSE);
				$options[$data['topic']['tlid']] = $title;
	      if ($data['below']) {
	        _cms_topic_parents_recurse($data['below'], $eid, $indent .'--', $options, $exclude, $depth_limit);
	      }
	    }
	  }
	}
}

/**
 * Implementation of hook_messaging()
 * 
 * This hook provides information about the message templates this module uses and related tokens.
 * 
 * Depending on $op, this hook takes different parameters and returns different pieces of information:
 * 
 * - 'message groups'
 *   Get array of message groups, each of which will have one or more keys for different templates
 *   Each group should have a unique key, so it should start with the module name
 * - 'message keys'
 *   Get message template parts for a given group ($arg1)
 *   Return array of key => name for each part
 * - 'messages'
 *   Get default message templates for a given group ($arg1).
 *   It should return default texts, indexed by message key that will be the default templates
 *   These templates may be edited on the 'Messaging templates' page
 * - 'tokens'
 *   Get available tokens for a given message group and key ($arg1).
 *   Return array of token keys that will be available for this message templates
 *   The tokens themselves may be default tokens (provided by token module) or we can add new
 *   tokens implementing hook_token_list() and hook_token_value()
 * 
 * @param $op
 *   Operation, type of information to retrieve
 * @param $arg1, $arg2...
 *   Different parameters depending on $op
 */
function cms_messaging($op, $arg1 = NULL, $arg2 = NULL, $arg3 = NULL, $arg4 = NULL) {
  switch ($op) {
    case 'send methods':
      $info['plain-mail'] = array(
        'title' => 'Drupal mail - Plain Text',
        'name' => t('Plain Text Mail'), // Name for display
        'group' => 'mail', // Class of sending method
        'destination' => 'mail', // Account property to use as destination
        'type' => MESSAGING_TYPE_SEND,  // Method type: push || pull
        'glue' => "\n", // Glue for message body lines
        'footer' => "\n--",  // Separator for message footer
        'description' => t('Send e-mails using the default Drupal mail library with plain text filter.'),
        'send callback' => 'messaging_mail_send_msg', // Sending callback
        'system accounts' => TRUE, // Supports multiple sending accounts
        'account type' => 'mail', // The type of system account to use
        'filter' => 3,
      );
			return $info;
    case 'message types':
      $info['cms'] = array(
        'name' => t('CMS'),
        'description' => t('Messages coming from CMS events')
      );
      return $info;
    case 'message groups':
      $help = t('The <em>Header</em> and <em>Footer</em> will be taken from Abstract events.');
      // Generic notifications event
      $info['cms-event'] = array(
        'module' => 'cms',
        'name' => t('Abstract event'),
        'description' => t('Common parts for all messages for a single abstract event. This is useful for defining a common header and/or footer for all these messages.'),
      );
      $info['cms-event-abstract'] = array(
        'module' => 'cms',
        'name' => t('Notifications for abstract events'),
        'description' => t('Defaults for all notifications related to abstract events.'),
        'help' => $help,
        'fallback' => 'cms-event',
      );
      $info['cms-event-abstract-insert'] = array(
        'module' => 'cms',
        'name' => t('Notifications for abstract creation'),
        'description' => t('Notifications produced when a new abstract is submitted.'),
        'help' => $help,
        'fallback' => 'cms-event-abstract',
      );
      $info['cms-event-abstract-update'] = array(
        'module' => 'cms',
        'name' => t('Notifications for abstract updates'),
        'description' => t('Notifications produced when a abstract is updated.'),
        'help' => $help,
        'fallback' => 'cms-event-abstract',
      );
      $info['cms-event-abstract-comment'] = array(
        'module' => 'cms',
        'name' => t('Notifications for abstract comments'),
        'description' => t('Notifications produced when a comment is posted to an abstract.'),
        'help' => $help,
        'fallback' => 'cms-event-abstract',
      );
			return $info;
    case 'message keys':      
      $type = $arg1;
      switch ($type) {
        case 'cms-event':				
          // Event notifications
          return array(
            'subject' => t('Subject'),
            'header' => t('Header'),
            'main' => t('Content'),
            'footer' => t('Footer'),
          );
        case 'cms-event-abstract':
        case 'cms-event-abstract-insert':
        case 'cms-event-abstract-update':              
        case 'cms-event-abstract-comment':
          // Some parts will be re-used from 'cms-event' group
          // So we specify only subject and main message
          return array(
            'subject' => t('Subject'),
            'main' => t('Content'),
          );
      }
      break;
    case 'messages':
      $type = $arg1;
      // CMS messages
      switch ($type) {
      	case 'cms-event':
	        return array(
	          'subject' => t('[conference-name]: [cms-subject]'),
	          'header' => t("Greetings [user],"),
	          'main' => t("A item to which you are subscribed has been updated"),
	          'footer' => array(
	              t('This is an automatic message from [site-name]'),
	              t('To manage your subscriptions, browse to [subscriptions-manage]'),
	              t('You can unsubscribe at [unsubscribe-url]'),
	          ),
	        );
        case 'cms-event-abstract':
        case 'cms-event-abstract-update':          
          return array(
            'subject' => t('Update for [type-name]: [title]'),
            'main' => array(
              '[node-teaser]',
              t('Read more [node-url]'),
            ),
          );
        case 'cms-event-abstract-insert':
          return array(
            'subject' => t('New [type-name]: [title]'),
            'main' => array(
              '[node-teaser]',
              t('Read more [node-url]'),            
            ),
          );             
        case 'cms-event-abstract-comment': 
          return array(
            'subject' => t('Comment for [type-name]: [title]'),
            'main' => array(
              t('Comment by [comment-author-name]: [comment-title]'),
              '[comment-body]',
              t('Read more [comment-url]'),
            ),
          );
			}
			break;
    case 'tokens':
			$type = explode('-', $arg1)  + array(2 => '', 3 => '');
			$tokens = array('user', 'cms');
      // These are the token groups that will be used for this module's messages
      // These are the token groups that will be used for this module's messages
      if ($type[0] == 'cms' && $type[2] == 'abstract') {
        if ($type[1] == 'event') {
          $tokens[] = 'node';
        }
      }
      return $tokens;
    case 'method update':
      // A messaging method has been disabled ($arg1) and replaced by the new one ($arg2)
      // Update subscriptions
      //db_query("UPDATE {notifications} SET send_method = '%s' WHERE send_method = '%s'", $arg2, $arg1);
      // Purge notifications queue, we may lost some notifications but it's the safest option.
      //db_query("DELETE FROM {notifications_queue} WHERE send_method = '%s'", $arg1);
      break;
  }
}

/**
 * Creates a single message for a single event
 * 
 * @param $account
 *   Destination user account
 * @param $event
 *   Event object which caused this notification
 * @param $send_method
 *   Array of subscription ids
 * 
 * @return
 *   Message array 
 */
function cms_process_message($account, $event, $send_method, $node) {
  // Create message. Do all this in one replacemente
  $text = array(
    'subject' => cms_message_part('cms-event-abstract-' . $event, 'subject', $send_method),
    'header' => cms_message_part('cms-event-abstract-' . $event, 'header', $send_method),
    'event'  => cms_message_part('cms-event-abstract-' . $event, 'main', $send_method),
    'footer' => cms_message_part('cms-event-abstract-' . $event, 'footer', $send_method),
  );

  $objects = array('user' => $account, 'node' => $node, 'cms' => $node);
  $text = messaging_text_replace($text, $objects);

  // Get subject out of text and build the message array
  $subject = $text['subject'];
  unset($text['subject']);
  return array('subject' => $subject, 'body' => $text);
}

function cms_conf_page_access($url, $tab = NULL) {
	global $user;
	$account = $user;
	if(!$tab) {
		$tab = 'welcome';
	}
	return TRUE;
	$node = cms_get_node_page($url, $tab);
	if (($account->uid == $node->uid && $account->uid != 0) || user_access('administer cms')) {
    return TRUE;
  }	
}

/**
 * Menu callback; view a conference page.
 * 
 * @param $url
 * 		The fragment url (event_id from the cms_event table)
 * 
 * @param $tab
 * 		This is the tab that is being viewed. The type of 
 * 		page being viewed e.g. welcome, call, venue
 * 
 * @return
 * 		The result of the node_page_view function from node.module
 */
function cms_conf_page_view($url, $tab) {
	global $user;
	$account = $user;
	$node = cms_get_node_page($url, $tab);
	$conference = cms_get_conference($url);
	if (user_access('administer cms', $account)) {
		$o = l('Edit', 'node/' . $node->nid . '/edit', array('query' => drupal_get_destination()));
		$o .= ', ' . l('Go to settings', 'admin/content/cms/' . $url . '/edit', array('query' => drupal_get_destination())); 
	}
	drupal_set_title($conference->event);
	$o .= cms_node_show($node, $cid);
	//$bc = drupal_get_breadcrumb();
	//$bc = array(0 => $bc[0]);
	//drupal_set_breadcrumb($bc);
	return $o;
}

/**
 * Get message part
 * 
 * It searches for optional message group keys for options defaulting to $type
 * 1. $module-$type-[$event->type]-[$event->action]
 * 2. $module-$type-[$event->type]
 * 3. $module-$type
 * 
 * @param $type
 *   Message type to send e.g. cms-event-abstract-insert
 * @param $key
 *   Id of message part, ie 'header'
 * @param $method
 *   Method by which message will be sent. Normally 'mail'
 * @param $send_method
 *   Module name to be prefixed to the template name. If different than notifications we first try
 *   with that module but if not found, try again with 'notifications'
 * 
 * @return
 *   Part of the message with tokens for replacement.
 */
function cms_message_part($type, $key, $method) {
	$module = 'cms';
  // If event passed check for predefined text or get optional keys from event
  if ($type == 'event' && is_object($param)) {
    if (isset($param->text[$key])) {
      return $param->text[$key];  
    } else {
      $options = array($param->type, $param->action);
    }
  } elseif ($method == 'test') {
    // Little trick for this to be testable
    return "$type $key [type-name] [title] [site-name]";
  } else {
    $options = is_array($param) ? $param : array();
  }  
  // Buid an array for searching templates, here's where the template fallback happens
  // I.e. $keyparts = array('cms, 'event', 'abstract', 'insert'),  will search for:
  // - cms-event-abstract-insert
  // - cms-event-abstract
  // - cms-event
  // - cms
  $search = $keyparts = explode('-', $type);
  while ($keyparts) {
    $groupkey = implode('-', $keyparts);
     if ($text = messaging_message_part($groupkey, $key, $method)) {
      $output = $text == MESSAGING_EMPTY ? '' : $text;
      break;
    }
    // If no text trim out latest part of the key and retry
    array_pop($keyparts);
  }
  if (isset($output)) {
    // We found something, return it
    return $output;
  }
  else {
    // Failed to get message part, return information about the template not found, will help debugging
    return "[UNDEFINED module = $module, key = $key, type = $type, method = $method, search = ". implode(',', $search) .']';
  }
}

/**
 * Implementation of hook_token_list(). Documents the individual
 * tokens handled by the module.
 */
function cms_token_list($type = 'cms') {
  $tokens = array();
  if ($type == 'cms') {  
    $tokens['cms']['conference'] = t('The current conference name.');
  }
  return $tokens;
}

/**
 * Implementation of hook_token_values()
 */
function cms_token_values($type, $node = NULL, $options = array()) {
	module_load_include('inc', 'cms', 'cms.db_functions');
  switch ($type) {
    case 'cms':
			$conference = cms_get_conference($node->event, TRUE)->event;
   		$values['conference'] = $conference;
      return $values;
  }
}

function cms_menu_access($tab = NULL) {
	global $user;
	$account = user_load($user->uid);
	if (!user_is_logged_in()) {
		return FALSE;
	}
	if (user_access('administer cms', $account)) {
		return TRUE;
	}
	if(in_array($tab, array('abstracts')) || is_null($tab)) {
		$conference = cms_get_conference(arg(3));
		$sql = "SELECT * FROM cms_uid WHERE uid = %d AND eid = %d";	
		$results = db_query($sql, $account->uid, $conference->event_id);
		$row = db_fetch_object($results);
		if($row) {
			return TRUE;
		}
	}
}

/**
 * Returns JS array for cms autocomplete fields.
 * Taken from masquerade
 */
function cms_autocomplete($string) {
  $matches = array();
  $result = db_query_range("SELECT u.name FROM {users} u WHERE LOWER(u.name) LIKE LOWER('%s%%')", $string, 0, 10);
  while ($user = db_fetch_object($result)) {
    $matches[$user->name] = check_plain($user->name);
  }
  if (stripos(variable_get('anonymous', t('Anonymous')), $string) === 0) {
    $matches[variable_get('anonymous', t('Anonymous'))] = variable_get('anonymous', t('Anonymous'));
  }
  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }
  exit(drupal_json($matches));
}

/**
 * Returns JS array for cms autocomplete fields. Supports multiple entries separated by a comma.
 * Taken from masquerade
 */
function cms_autocomplete_multiple($string) {
  // The user enters a comma-separated list of users. We only autocomplete the last user.
  $array = drupal_explode_tags($string);

  // Fetch last tag
  $last_string = trim(array_pop($array));

  $matches = array();
  $result = db_query_range("SELECT u.name FROM {users} u WHERE LOWER(u.name) LIKE LOWER('%s%%')", $last_string, 0, 10);

  $prefix = count($array) ? implode(', ', $array) .', ' : '';

  while ($user = db_fetch_object($result)) {
    $matches[$prefix . $user->name] = check_plain($user->name);
  }
  // This will add anonymous to the list, but not sorted.
  if (stripos(variable_get('anonymous', t('Anonymous')), $last_string) === 0) {
    $matches[$prefix . variable_get('anonymous', t('Anonymous'))] = variable_get('anonymous', t('Anonymous'));
  }
  if (module_exists('alt_login')) {
    $result = db_query_range("SELECT alt_login FROM {alt_login} u WHERE LOWER(alt_login) LIKE LOWER('%s%%')", $string, 0, 10);
    while ($user = db_fetch_object($result)) {
      $matches[$user->alt_login] = check_plain($user->alt_login);
    }
  }
  if (module_exists('devel')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }
  exit(drupal_json($matches));
}

/**
 * Replacement function for user_autocomplete which allows the use of a comma
 * separated list of user names.
 * Taken from masquerade
 */
function cms_autocomplete_user($string) {
  $array = drupal_explode_tags($string);
  $search = trim(array_pop($array));
  $matches = array();
  if ($search) {
    $prefix = count($array) ? implode(', ', $array) .', ' : '';
    $result = db_query_range("SELECT name FROM {users} WHERE LOWER(name) LIKE LOWER('%s%%')", $search, 0, 10);
    while ($user = db_fetch_object($result)) {
      $matches[$prefix . $user->name] = check_plain($user->name);
    }
  }

  drupal_json($matches);
}

/**
 * Low level function for managing membership
 *
 * @param $eid event/conference ID of a event/conference
 * @param $uid user ID of user
 * @param $args an array with details of this membership. Recognized array keys are:
     is_active, is_admin, created. Other values are passed to hook implementations.
 */
function cms_save_subscription($eid, $uid, $args = array()) {
  if ($uid > 0) {
    $sql = "SELECT COUNT(*) FROM {cms_uid} WHERE eid = %d AND uid = %d";
    $cnt = db_result(db_query($sql, $eid, $uid));
    $time = time();
    $subscription = array(
      'eid' => $eid,
      'uid' => $uid,
      'created' => isset($args['created']) ? $args['created'] : $time,
      'changed' => $time
    );
    unset($args['created']);
    $subscription += $args;

    if ($cnt == 0) {
      drupal_write_record('cms_uid', $subscription);
    }
    else {
      drupal_write_record('cms_uid', $subscription, array('eid', 'uid'));
    }
  }
}

/**
 * Generate a page displaying a single node, along with its comments. Taken from core
 */
function cms_node_show($node, $cid, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %title from %date', array('%title' => $node->title, '%date' => format_date($node->revision_timestamp))));
  }
  $output = cms_conf_page_node_view($node, FALSE, TRUE);

  if (function_exists('comment_render') && $node->comment) {
    $output .= comment_render($node, $cid);
  }

  // Update the history table, stating that this user viewed this node.
  node_tag_new($node->nid);

  return $output;
}

/**
 * Generate a display of the given node.
 *
 * @param $node
 *   A node array or node object.
 * @param $teaser
 *   Whether to display the teaser only or the full form.
 * @param $page
 *   Whether the node is being displayed by itself as a page.
 * @param $links
 *   Whether or not to display node links. Links are omitted for node previews.
 *
 * @return
 *   An HTML representation of the themed node.
 */
function cms_conf_page_node_view($node, $teaser = FALSE, $page = FALSE, $links = TRUE) {
  $node = (object)$node;

  $node = node_build_content($node, $teaser, $page);
	
  if ($links) {
    $node->links = module_invoke_all('link', 'node', $node, $teaser);
    drupal_alter('link', $node->links, $node);
  }

  // Set the proper node part, then unset unused $node part so that a bad
  // theme can not open a security hole.
  $content = drupal_render($node->content);
  if ($teaser) {
    $node->teaser = $content;
    unset($node->body);
  }
  else {
    $node->body = $content;
    unset($node->teaser);
  }

  // Allow modules to modify the fully-built node.
  node_invoke_nodeapi($node, 'alter', $teaser, $page);
  return theme('cms_node', $node, $teaser, $page);
}

/**
 * Process variables for node.tpl.php
 *
 * Most themes utilize their own copy of node.tpl.php. The default is located
 * inside "modules/node/node.tpl.php". Look in there for the full list of
 * variables.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $teaser
 * - $page
 *
 * @see node.tpl.php
 */
function template_preprocess_cms_node(&$variables) {
  $node = $variables['node'];
  if (module_exists('taxonomy')) {
    $variables['taxonomy'] = taxonomy_link('taxonomy terms', $node);
  }
  else {
    $variables['taxonomy'] = array();
  }

  if ($variables['teaser'] && $node->teaser) {
    $variables['content'] = $node->teaser;
  }
  elseif (isset($node->body)) {
    $variables['content'] = $node->body;
  }
  else {
    $variables['content'] = '';
  }

  $variables['date']      = format_date($node->created);
  $variables['links']     = !empty($node->links) ? theme('links', $node->links, array('class' => 'links inline')) : '';
  $variables['name']      = theme('username', $node);
  $variables['node_url']  = url('node/'. $node->nid);
  $variables['terms']     = theme('links', $variables['taxonomy'], array('class' => 'links inline'));
  $variables['title']     = check_plain($node->title);

  // Flatten the node object's member fields.
  $variables = array_merge((array)$node, $variables);

  // Display info only on certain node types.
  if (theme_get_setting('toggle_node_info_'. $node->type)) {
    $variables['submitted'] = theme('node_submitted', $node);
    $variables['picture'] = theme_get_setting('toggle_node_user_picture') ? theme('user_picture', $node) : '';
  }
  else {
    $variables['submitted'] = '';
    $variables['picture'] = '';
  }
  // Clean up name so there are no underscores.
  $variables['template_files'][] = 'node-'. $node->type;
}

function cms_preprocess_views_view_field(&$vars) {
	if($vars['field']->field_alias == 'node_title' &&
		 $vars['view']->current_display	== 'block_front_left'
			) {
		$debug = TRUE;
		$nid = $vars['row']->nid;
		$vars['output'] = l('test', 'test');			
	}
	if($debug) {
		//dpm($vars);
		//dpm($vars['row']);
	}	
	$id = $vars['id'];
	$result = $vars['view']->result;
	$node = node_load($result[$id]->nid);
	if (isset($node->cms)) {
		//$link = l($node->title, 'conferences/' . $node->cms->url);
		//$vars['output'] = $link;
		//dpm($vars);
	}	
}

function cms_create_default_conf_pages($eid) {
	global $user;
	$defaults = array('welcome', 'call', 'program', 'venue', 'tours', 'sponsors', 'committee', 'registration');
	//$defaults = array('test');
	foreach($defaults as $default) {
		$node = array(
			'uid' => $user->uid,
			'title' => 'test', 
			'name' => (isset($user->name) ? $user->name : ''), 
			'type' => 'cms_node', 
			'language' => '',
			//'cms' => $cms,
			'created' => strtotime("now"),
			'changed' => strtotime("now"),
			'status' => 1,
			'comment' => 0,
			'promote' => 0,
			'moderate' => 0,
			'sticky' => 0,
			'event' => $eid,
			'cms_node_type' => $default,			
		);
		$node = (object) $node;
		node_save($node);
	}
}

function cms_is_page($nid) {
	$sql = "SELECT * FROM cms_nodes WHERE nid = %d";
	if(db_query($sql, $nid)) {
		return TRUE;
	}
}

function template_preprocess_cms_program_abstract(&$vars) {
	drupal_add_css(drupal_get_path('module', 'cms') . '/cms.css', 'module');
	$node = $abstract = node_load($vars['abstract']->nid);
  // The build mode identifies the target for which the node is built.
  if (!isset($node->build_mode)) {
    $node->build_mode = NODE_BUILD_NORMAL;
  }

  // Remove the delimiter (if any) that separates the teaser from the body.
  $node->body = isset($node->body) ? str_replace('<!--break-->', '', $node->body) : '';

  $node = node_prepare($node, $teaser);

  // Allow modules to make their own additions to the node.
  node_invoke_nodeapi($node, 'view', FALSE, FALSE);

	if ($abstract->nid == 7639) {
		//dpm($node);
	}

	$vars['full_abstract'] = $vars['abstract'];
	if($vars['teaser']) {
		$vars['title'] = l($abstract->title, $_GET['q'], array('fragment' => 'abstract-' . $abstract->nid));
		// Create a link to the full node
		$options = array(
			'query' => array (
				'destination' => $_GET['q'],
				'program' => TRUE,
			)
		);
		$vars['link_to_full_abstract'] = l($abstract->title, 'node/' . $abstract->nid, $options);
	}
	else { 
		$vars['anchor_id'] = 'abstract-' . $abstract->nid;
		$vars['go_top_link'] = l('...back to top', $_GET['q'], array('fragment' => 'top'));
		$vars['title'] = $abstract->title;
		$vars['body'] = drupal_render($node->content['body']);
		$vars['rate'] = drupal_render($node->content['fivestar_widget']);
	}
}

function template_preprocess_cms_program_group_heading(&$vars) {
	$heading = $vars['heading'];
	drupal_add_css(drupal_get_path('module', 'cms') . '/cms.css', 'module');
	$vars['heading_title'] = $vars['heading']->title;
	if(!$vars['teaser']) {
		$anchor_id = 'topic-' . $heading->topic_id;
		$vars['anchor_id'] = $anchor_id;
	}
}