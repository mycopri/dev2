<?php
/**
 * Ensures that the sender is accurate with the domain for OG notifications
 *
 * @param Object $message
 *   The message object.
 * @param Object $info
 *   Sending method information.
 */
function asce_og_notifications_message_alter(&$message, $info) {
	//$mess = 'Initialize messages so that dsm works...';
	//dsm($mess);
	if ($sid = _og_notification_check_message($message)) {
    //drupal_set_message('In asce_og_notifications, dealing with og notifications.');
    //drupal_set_message('digest:' . $message->digest);
		
  	$event = $message->notifications['events'][0];
    // Cater for different message groups (actions).
    $group = 'og-notifications-'. $event->action;
    $send_method = $message->method;
    $subscription = notifications_load_subscription($sid);

    $text = array(
      'subject' => messaging_message_part($group, 'subject', $send_method, $event),
      'header' => messaging_message_part($group, 'header', $send_method, $event),
      'main'  => messaging_message_part($group, 'main', $send_method, $event),
      'footer' => messaging_message_part($group, 'footer', $send_method, $event)
    );
    
    
    $object->user = $message->account;
    $object->node = $event->objects['node'];
    $objects = array('user' => $message->account, 'node' => $event->objects['node'], 'subscription' => $subscription);
    if ($event->action == 'comment') {
    	$object->comment = $event->objects['comment'];
      $objects['comment'] = $event->objects['comment'];
    }
    $objects['asce'] = $object;
    $objects = array_merge($objects, $event->objects);
    //dsm($text);
    //drupal_set_message('$objects' . kpr($objects,TRUE));
    $text = messaging_text_replace($text, $objects);

    $message->subject = $text['subject'];
    unset($text['subject']);
    $message->body = $text;
    //$domains = domain_get_user_domains($object->user);
    //$message->params = array(
    //    'mail' => array('from' => domain_conf_variable_get(array_shift($domains), 'site_mail')),
    //  );
  }
  /*if ($message->digest == 'short') {
  	drupal_set_message('In asce_og_notifications, dealing with short digest.');
    drupal_set_message('digest:' . $message->digest);
  	
    //$text['subject'] = notifications_message_part('digest', 'subject', $send_method, NULL, $module);
    //$text['header'] = notifications_message_part('digest', 'header', $send_method, NULL, $module);
    //$text['footer'] = notifications_message_part('digest', 'footer', $send_method, NULL, $module);
    
    //$mess .= '<pre>' . print_r($message, TRUE) . '</pre>';
    //drupal_set_message($mess);
    //$object->user = $message->account;
    //$object->node = $event->objects['node'];
    //$text = messaging_text_replace($text, array('asce' => $object));
    
    //$message->subject = $text['subject'];
    //$message->header = $text['header'];
    //$message->footer = $text['footer'];
  }*/
  
}

/**
 * Implementation of hook_mail().
 */
function asce_og_notifications_mail_alter(&$mail) {
	//$message = 'id => ' . $mail['id'] . '<br/>';
	//$message .= 'to => ' . $mail['to'] . '<br/>';
	//$message .= 'from => ' . $mail['from'] . '<br/>';
	//$message .= 'language => ' . $mail['language'] . '<br/>';
	//$message .= 'params => ' . $mail['params'] . '<br/>';
	//$message .= 'subject => ' . $mail['subject'] . '<br/>';
	//$message .= 'body => ' . $mail['body'] . '<br/>';
	//$message .= 'headers => ' . kpr($mail['headers'], TRUE) . '<br/>';
	//$message .= 'attachments => ' . $mail['attachments'] . '<br/>';
	// Alter the from field to be dependent on the primary domain of the user that the email is being sent to.
  if ($mail['id'] == 'messaging_message-notifications') {
		$user = user_load(array('mail' => $mail['to']));
		if(module_exists('domain')) {
			$domains = domain_get_user_domains($user);
			$from = domain_conf_variable_get(array_shift($domains), 'site_mail');
		}
		$mail['from'] = $from;
		$mail['headers']['From'] = $from;
		$mail['headers']['Reply-To'] = $from; 
		$mail['headers']['Errors-To'] = $from;
		$mail['headers']['Return-Path'] = $from;
		$mail['headers']['Sender'] = $from;
  }
	//dsm($mail['from']);
	//dsm($mail['headers']);	
}

/**
 * Implement hook_token_list().
 */
function asce_og_notifications_token_list($type = 'all') {
  $tokens = array();

  if ($type == 'global' || $type == 'all') {
    // Current domain tokens.
    $tokens['asce']['domain-path'] = t('The current domain url in http: format.');
    $tokens['asce']['domain-node-url'] = t('The domain specific URL of the node.');
    $tokens['asce']['domain-comment-url'] = t('The domain specific comment view url.');
    $tokens['asce']['domain-comment-reply-url'] = t('The domain specific comment reply url.');
    $tokens['asce']['domain-subscriptions-manage']    = t('The domain specific url for the current user to manage subscriptions.');
  }
  return $tokens;
}

/**
 * Implement hook_token_values().
 */
function asce_og_notifications_token_values($type, $object = NULL, $options = array()) {
	switch ($type) {
		case 'asce':
			$user = $object->user;
			$node = $object->node;
			if (module_exists('domain')) {
				$domains = domain_get_user_domains($user);
				$domain_id = array_shift($domains);
				$domain_id = ($domain_id == -1) ? 0 : $domain_id;
				$domain = domain_load($domain_id);
				//dsm($domain);
				$tokens['domain-path'] = $domain['path'];
				$tokens['domain-site-name'] = $domain['sitename'];
				$tokens['domain-node-url'] = $domain['path'] . 'node/' . $node->nid;
				$tokens['domain-subscriptions-manage'] = url($domain['path'] . "user/$user->uid/notifications", array('absolute' => TRUE));
				if (isset($object->comment)) {
					$comment = $object->comment;
					$tokens['domain-comment-url'] =  url($domain['path'] . 'node/'. $node->nid, array('fragment' =>'comment-'. $comment->cid, 'absolute' => TRUE));
					$tokens['domain-comment-reply-url'] = url($domain['path'] . 'comment/reply/'. $node->nid .'/'. $comment->cid, array('absolute' => TRUE));
	      }
			}
      break;
	}	
	return $tokens;
}

function asce_og_notifications_menu() {
  $items['admin/messaging/test-marvin'] = array(
    'title' => 'Test Marvin',
    'description' => t('Update test for testing notifications.'),
    'access arguments' => array('configure ASCE Mobile Tools'),
    'page callback' => 'asce_og_notifications_test',
  );
  return $items;
  
}

function asce_og_notifications_test() {
	$nodes = array(5115, 5090, 4992);
	$comments = array(355,353,356);
	foreach($nodes as $nid) {
		$node = node_load($nid);
		$event = array(
          'module' => 'node',
          'oid' => $node->nid,
          'type' => 'node',
          'action' => 'update',
          'node' => $node,
          'params' => array('nid' => $node->nid),
	        'uid' => 102,
		);
		notifications_event($event);
	}
  foreach($comments as $cid) {
  $comment = _comment_load($cid);
  $node = node_load($comment->nid);
  $event = array(
        'uid' => $comment->uid, // For this special case the event actor is the user who posts the comment
        'module' => 'node',
        'type' => 'node',
        'action' => 'comment',
        'node' => $node,
        'comment' => $comment,
        'params' => array('nid' => $comment->nid, 'cid' => $comment->cid),
      );
  notifications_event($event);              
  }
  drupal_goto('admin/messaging/subscriptions/queue');
  return '';
}

/**
 * Implementation of notifications_hook()
 * 
 * Check access permissions to subscriptions
 */
function asce_og_notifications_notifications($op, &$arg0, $arg1 = NULL, $arg2 = NULL) {
  switch ($op) {
    case 'digest methods':
      // Return array of digesting engines
      $info['summary'] = array(
        'type' => 'summary',
        'name' => t('ASCE Summary'),
        'description' => t('(ASCE)Produces one line per event, grouped by object'),
        'digest callback' => 'asce_og_notifications_process_digest_short',
        'module' => 'asce_og_notifications',
      );
      return $info;
  }
}

/**
 * Digest multiple events in a single message, short format.
 * 
 * @return array with messages ready to be sent
 */
function asce_og_notifications_process_digest_short($account, $events, $subscriptions, $send_interval, $send_method, $module = 'notifications') {
//  dsm('asce_og_notifications_process_digest');
//  dsm($account);
//  drupal_set_message('Entering asce_og_notifications_process_digest_short...' . kpr($events, TRUE));
//  dsm($subscriptions);
//  dsm($send_interval);
//  dsm($send_method);
//  dsm($module);
  module_load_include('inc', 'notifications', 'notifications.cron.inc');
  // Compile list of events for each object
  $list = array();

  // Create an object for passing into tokens for text replacement
  $asce_object->user = $account;
  
  // Build up the digested list with text replacement
  // We need text replacement for each line because it depends on different objects  
  foreach ($events as $event) {
  	//drupal_set_message('In loop to build digested list. $event' . kpr($event, TRUE));
    notifications_log('Creating ASCE Summary', array('event' => $event));
    $sid = is_array($subscriptions[$event->eid]) ? array_shift($subscriptions[$event->eid]) : 0;
    $subscription = $sid ? notifications_load_subscription($sid) : NULL;
    $objects = $event->objects + array('user' => $account, 'subscription' => $subscription);
    // $info = notifications_event_types($event->type, $event->action);
    $digest = nofitications_digest_event_info($event, 'asce_og_notifications');
    //drupal_set_message('$digest; $event->eid is ' . $event->eid . kpr($digest, TRUE));
    $digest_type = $digest['type'];
    $digest_value = $digest['value'];
    $asce_object->node = $objects['node'];
    $objects['asce'] = $asce_object;

    if (!isset($list[$digest_type][$digest_value]['group'])) {
      $group = array(      
        'title' => notifications_digest_group($digest, 'title', $send_method),
        'footer' => notifications_digest_group($digest, 'closing', $send_method),
      );
      // The objects passed here for tokens will be the ones from the first event only
      //$mess = 'Creating group messages...' . kpr($event, TRUE) . "\$list[$digest_type][$digest_value]['group']";
      $list[$digest_type][$digest_value]['group'] = messaging_text_replace($group, $objects);
      //$mess .= kpr($group, TRUE) . kpr($objects, TRUE) . kpr($list[$digest_type][$digest_value]['group'], TRUE);
      //drupal_set_message($mess);
      notifications_log('Digesting object', array('type' => $digest_type, 'value' => $digest_value));
    }
    // Check duplicate notifications for the same event so we do some deduping
    if (!isset($list[$digest_type][$digest_value]['line'][$event->eid])) {
      $line = asce_og_notifications_digest_line($event, $send_method, $objects);
      $objects['event'] = $event;
      if ($event->action == 'comment') {
      	$objects['asce']->comment = $event->objects['comment'];
      }
      //$mess = 'Creating digest line...' . kpr($event, TRUE) . "\$list[$digest_type][$digest_value][\'line\'][{$event->eid}]";
      $list[$digest_type][$digest_value]['line'][$event->eid] = messaging_text_replace($line, $objects);
      //$mess .= kpr($line, TRUE) . kpr($objects, TRUE) . kpr($list[$digest_type][$digest_value]['line'][$event->eid], TRUE);
      //drupal_set_message($mess);
    }
  }
  // Create message. Do all this in one replacement, then strip out the subject
  //dsm('About to create the subject');
  // In order to get the right template we need to override the module name to 'asce_og_notifications'
  // because by default it is 'notifications'
  $override_module = 'asce_og_notifications';
  $text['subject'] = notifications_message_part('digest', 'subject', $send_method, NULL, $override_module);
  $text['header'] = notifications_message_part('digest', 'header', $send_method, NULL, $override_module);
  $text['footer'] = notifications_message_part('digest', 'footer', $send_method, NULL, $override_module);
  //dsm('Finished creating the subject and others');

  // We dont pass a subscription object here, won't be too much use anyway
  $object->user = $account;
  $text = messaging_text_replace($text, array('user' => $account, 'subscription' => NULL, 'asce' => $object));
  
  // Compose body. All these lines have been text replaced
  $body = theme('notifications_digest_short_body', $text, $list);
    
  // Build the final digested message, and return in an array
  $message = array(
    'subject' => $text['subject'], 
    'body' => $body,
    'events' => $events,
    'subscriptions' => $subscriptions,
    'digest' => 'summary',
  );
  //dsm($message);
  //dsm(debug_backtrace());
  return array($message);
}

/**
 * Get digest information for an event.
 * 
 * From the event definition (notifications('event types')) we find out 
 * - which event object we'll use for digesting
 * - which field of that object to use for indexing
 * 
 * I.e. for event type = 'node', event action = 'update'
 *  'digest' => ('node', 'nid')
 */
function asce_og_notifications_digest_event_info($event, $module = 'asce_og_notifications') {
  $info = notifications_event_types($event->type, $event->action);
  if (!empty($info['digest'])) {
    $type = $info['digest'][0];
    $field = $info['digest'][1];
    // Check object and values, the object may be the event itself
    if ($type == 'event') {
      $object = $event;
    }
    else {
      $object = !empty($event->objects[$type]) ? $event->objects[$type] : NULL;
    }
  }
  else {
    // No digest info for this event /action so we use event and action itselves.
    $type = $event->type;
    $field = $event->action;
    $object = NULL;
  }
  $value = $object && isset($object->$field) ? $object->$field : 0;
  return array('type' => $type, 'field' => $field, 'value' => $value, 'object' => $object, 'module' => $module);  
}

/**
 * Implementation of hook_messaging()
 * 
 * This hook provides information about the mensaje templates this module uses and related tokens.
 * 
 * Depending on $op, this hook takes different parameters and returns different pieces of information:
 * 
 * - 'message groups'
 *   Get array of message groups, each of which will have one or more keys for different templates
 *   Each group should have a unique key, so it should start with the module name
 * - 'message keys'
 *   Get message template parts for a given group ($arg1)
 *   Return array of key => name for each part
 * - 'messages'
 *   Get default message templates for a given group ($arg1).
 *   It should return default texts, indexed by message key that will be the default templates
 *   These templates may be edited on the 'Messaging templates' page
 * - 'tokens'
 *   Get available tokens for a given message group and key ($arg1).
 *   Return array of token keys that will be available for this message templates
 *   The tokens themselves may be default tokens (provided by token module) or we can add new
 *   tokens implementing hook_token_list() and hook_token_value()
 * 
 * @param $op
 *   Operation, type of information to retrieve
 * @param $arg1, $arg2...
 *   Different parameters depending on $op
 */
function asce_og_notifications_messaging($op, $arg1 = NULL, $arg2 = NULL, $arg3 = NULL, $arg4 = NULL) {
  switch ($op) {
    case 'message groups':
      // Generic asce committee notifications event
      $info['asce_og_notifications-digest'] = array(
        'module' => 'asce_og_notifications',
        'name' => t('Committee Notifications digest'),
        'description' => t('Depending on your settings for each Send interval, OG Notifications may be digested, this is grouped and summarized in a single message. These are the common parts for Committee Notifications digests.'),
      );
      $info['asce_og_notifications-digest-lite'] = array(
        'module' => 'asce_og_notifications',
        'name' => t('Group of simple notifications'),
        'description' => t('Simple notifications digested with short format.'),
        'help' => t('Every line of the digest will be a separate message.'),
        'fallback' => 'asce_og_notifications-digest',
      );
      $info['asce_og_notifications-digest-node-nid'] = array(
        'module' => 'asce_og_notifications',
        'name' => t('Groups digests per node'),
        'description' => t('Group of events digested for each node.'),
        'fallback' => 'asce_og_notifications-digest',
      );
      $info['asce_og_notifications-digest-node-type'] = array(
        'module' => 'asce_og_notifications',
        'name' => t('Groups digests per node type'),
        'description' => t('Group of events digested for each node type.'),
        'fallback' => 'asce_og_notifications-digest',
      );
      return $info;
    case 'message keys':      
      $type = $arg1;
      switch ($type) {
        case 'asce_og_notifications-digest':
          return array(
            'subject' => t('Subject'),
            'header' =>  t('Header'),
            'main' => t('Line for digested events'),
            'closing' => t('Group closing'),
            'footer' => t('Footer'),
          );
        case 'asce_og_notifications-digest-node-nid':
        case 'asce_og_notifications-digest-node-type':
          $parts['title'] = t('Group title');
          $parts['closing'] = t('Group footer');
          return $parts;
        case 'asce_og_notifications-digest-lite':  
          $parts['title'] = t('Group title');
          $parts['closing'] = t('Group footer');
          return $parts;
      }
      break;
    case 'messages':
      $type = $arg1;
      // Digested messages
      switch ($type) {
      	case 'asce_og_notifications-digest':
          return array(
            'subject' => t('[site-name] subscription update for [user] (committees)'),
            'header' => t("Greetings, [user].\n\nThese are your messages"),
            'main' => t("A [type] has been updated: [title]\n\n[event_list]"),
            'closing' => '...',
            'footer' => array(
              t('This is an automatic message from [site-name]'),
              t('To manage your subscriptions, browse to [subscriptions-manage]'),
            ),
          );        
        case 'asce_og_notifications-digest-node-nid':
          // Define only group title and group footer (closing)
          // The 'closing' statement is typically a 'read more' link
          return array(
            'title' => t('Updates for [type-name]: [title]'),
            'closing' => t('Read more [node-url]'),
          );
        case 'asce_og_notifications-digest-node-type':
          return array(
            'title' => t('New content of type [type-name] has been submitted'),
            'closing' => '<none>',
          );       
        case 'asce_og_notifications-digest-lite':
          return array(
            'title' => t('Generic messages'),
            'closing' => '...',
          );
      }
      break;
    case 'tokens':
    	// Piggy back off notifications and other modules
    case 'method update':
      // A messaging method has been disabled ($arg1) and replaced by the new one ($arg2)
      // Update subscriptions
      db_query("UPDATE {notifications} SET send_method = '%s' WHERE send_method = '%s'", $arg2, $arg1);
      // Purge notifications queue, we may lost some notifications but it's the safest option.
      db_query("DELETE FROM {notifications_queue} WHERE send_method = '%s'", $arg1);
      break;
  }
}

/**
 * Digest each line, with some caching for performance
 */
function asce_og_notifications_digest_line($event, $method) {
  static $digest = array();
  if (!isset($digest[$event->eid][$method])) {
    // The event may have an specific digest line, otherwise use template if present or even information
    if (!empty($event->text['digest'])) {
      $line = $event->text['digest'];
    } elseif ($part = notifications_message_part('event', 'digest', $method, $event, 'og-notifications')) {
      $line = $part;
    } else { // Get it from event information
      $info = notifications_event_types($event->type, $event->action);
      $line = $info['line'];
    }    
    $digest[$event->eid][$method] = $line;
  }
  return $digest[$event->eid][$method];
}
/**
 * Implementation of hook_privatemsg_message_presave_alter()
 * This ensures that the format for displaying the message is
 * in full HTML
 * @param unknown_type $message
 */
function asce_og_notifications_privatemsg_message_presave_alter (&$message) {
	$message['format'] = 1;
}

function asce_og_notifications_privatemsg_message_view_alter (&$vars) {
  $message = $vars['message'];
  $message['format'] = 1;
  $vars['message_body'] = check_markup($message['body'], $message['format'], FALSE);
}